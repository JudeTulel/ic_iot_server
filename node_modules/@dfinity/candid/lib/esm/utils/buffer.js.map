{"version":3,"file":"buffer.js","sourceRoot":"","sources":["../../../src/utils/buffer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat(...buffers: ArrayBuffer[]): ArrayBuffer {\n  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n  let index = 0;\n  for (const b of buffers) {\n    result.set(new Uint8Array(b), index);\n    index += b.byteLength;\n  }\n  return result;\n}\n\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nexport function toHexString(bytes: ArrayBuffer): string {\n  return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nexport function fromHexString(hexString: string): ArrayBuffer {\n  return new Uint8Array((hexString.match(/.{1,2}/g) ?? []).map(byte => parseInt(byte, 16)));\n}\n\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nexport class PipeArrayBuffer {\n  /**\n   * The reading view. It's a sliding window as we read and write, pointing to the buffer.\n   * @private\n   */\n  private _view: Uint8Array;\n\n  /**\n   * The actual buffer containing the bytes.\n   * @private\n   */\n  private _buffer: ArrayBuffer;\n\n  /**\n   * Creates a new instance of a pipe\n   * @param buffer an optional buffer to start with\n   * @param length an optional amount of bytes to use for the length.\n   */\n  constructor(buffer?: ArrayBuffer, length = buffer?.byteLength || 0) {\n    this._buffer = bufFromBufLike(buffer || new ArrayBuffer(0));\n    this._view = new Uint8Array(this._buffer, 0, length);\n  }\n\n  get buffer(): ArrayBuffer {\n    // Return a copy of the buffer.\n    return bufFromBufLike(this._view.slice());\n  }\n\n  get byteLength(): number {\n    return this._view.byteLength;\n  }\n\n  /**\n   * Read `num` number of bytes from the front of the pipe.\n   * @param num The number of bytes to read.\n   */\n  public read(num: number): ArrayBuffer {\n    const result = this._view.subarray(0, num);\n    this._view = this._view.subarray(num);\n    return result.slice().buffer;\n  }\n\n  public readUint8(): number | undefined {\n    const result = this._view[0];\n    this._view = this._view.subarray(1);\n    return result;\n  }\n\n  /**\n   * Write a buffer to the end of the pipe.\n   * @param buf The bytes to write.\n   */\n  public write(buf: ArrayBuffer): void {\n    const b = new Uint8Array(buf);\n    const offset = this._view.byteLength;\n    if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n      // Alloc grow the view to include the new bytes.\n      this.alloc(b.byteLength);\n    } else {\n      // Update the view to include the new bytes.\n      this._view = new Uint8Array(\n        this._buffer,\n        this._view.byteOffset,\n        this._view.byteLength + b.byteLength,\n      );\n    }\n\n    this._view.set(b, offset);\n  }\n\n  /**\n   * Whether or not there is more data to read from the buffer\n   */\n  public get end(): boolean {\n    return this._view.byteLength === 0;\n  }\n\n  /**\n   * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n   * @param amount A number of bytes to add to the buffer.\n   */\n  public alloc(amount: number) {\n    // Add a little bit of exponential growth.\n    const b = new ArrayBuffer(((this._buffer.byteLength + amount) * 1.2) | 0);\n    const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n    v.set(this._view);\n    this._buffer = b;\n    this._view = v;\n  }\n}\n\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nexport function uint8ToBuf(arr: Uint8Array): ArrayBuffer {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;\n}\n\n/**\n * Returns a true ArrayBuffer from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns ArrayBuffer\n */\nexport function bufFromBufLike(\n  bufLike:\n    | ArrayBuffer\n    | Uint8Array\n    | DataView\n    | ArrayBufferView\n    | ArrayBufferLike\n    | [number]\n    | number[]\n    | { buffer: ArrayBuffer },\n): ArrayBuffer {\n  if (bufLike instanceof Uint8Array) {\n    return uint8ToBuf(bufLike);\n  }\n  if (bufLike instanceof ArrayBuffer) {\n    return bufLike;\n  }\n  if (Array.isArray(bufLike)) {\n    return uint8ToBuf(new Uint8Array(bufLike));\n  }\n  if ('buffer' in bufLike) {\n    return bufFromBufLike(bufLike.buffer);\n  }\n  return uint8ToBuf(new Uint8Array(bufLike));\n}\n"]}