{"version":3,"file":"certificate.js","sourceRoot":"","sources":["../../src/certificate.ts"],"names":[],"mappings":"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","sourcesContent":["import * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { bufEquals, concat, fromHex, toHex } from './utils/buffer';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls';\nimport { decodeTime } from './utils/leb';\n\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nexport class CertificateVerificationError extends AgentError {\n  constructor(reason: string) {\n    super(`Invalid certificate: ${reason}`);\n  }\n}\n\nexport interface Cert {\n  tree: HashTree;\n  signature: ArrayBuffer;\n  delegation?: Delegation;\n}\n\nexport enum NodeType {\n  Empty = 0,\n  Fork = 1,\n  Labeled = 2,\n  Leaf = 3,\n  Pruned = 4,\n}\n\nexport type NodeLabel = ArrayBuffer | Uint8Array;\n\nexport type HashTree =\n  | [NodeType.Empty]\n  | [NodeType.Fork, HashTree, HashTree]\n  | [NodeType.Labeled, NodeLabel, HashTree]\n  | [NodeType.Leaf, NodeLabel]\n  | [NodeType.Pruned, NodeLabel];\n\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree: HashTree): string {\n  const indent = (s: string) =>\n    s\n      .split('\\n')\n      .map(x => '  ' + x)\n      .join('\\n');\n  function labelToString(label: ArrayBuffer): string {\n    const decoder = new TextDecoder(undefined, { fatal: true });\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n\n  switch (tree[0]) {\n    case NodeType.Empty:\n      return '()';\n    case NodeType.Fork: {\n      if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {\n        const left = hashTreeToString(tree[1]);\n        const right = hashTreeToString(tree[2]);\n        return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n      } else {\n        throw new Error('Invalid tree structure for fork');\n      }\n    }\n    case NodeType.Labeled: {\n      if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {\n        const label = labelToString(tree[1]);\n        const sub = hashTreeToString(tree[2]);\n        return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n      } else {\n        throw new Error('Invalid tree structure for labeled');\n      }\n    }\n    case NodeType.Leaf: {\n      if (!tree[1]) {\n        throw new Error('Invalid tree structure for leaf');\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n      return `leaf(...${tree[1].byteLength} bytes)`;\n    }\n    case NodeType.Pruned: {\n      if (!tree[1]) {\n        throw new Error('Invalid tree structure for pruned');\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n\n      return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n    }\n    default: {\n      return `unknown(${JSON.stringify(tree[0])})`;\n    }\n  }\n}\n\ninterface Delegation extends Record<string, unknown> {\n  subnet_id: ArrayBuffer;\n  certificate: ArrayBuffer;\n}\n\nfunction isBufferGreaterThan(a: ArrayBuffer, b: ArrayBuffer): boolean {\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] > b8[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\ntype VerifyFunc = (pk: Uint8Array, sig: Uint8Array, msg: Uint8Array) => Promise<boolean> | boolean;\n\nexport interface CreateCertificateOptions {\n  /**\n   * The bytes encoding the certificate to be verified\n   */\n  certificate: ArrayBuffer;\n  /**\n   * The root key against which to verify the certificate\n   * (normally, the root key of the IC main network)\n   */\n  rootKey: ArrayBuffer;\n  /**\n   * The effective canister ID of the request when verifying a response, or\n   * the signing canister ID when verifying a certified variable.\n   */\n  canisterId: Principal;\n  /**\n   * BLS Verification strategy. Default strategy uses wasm for performance, but that may not be available in all contexts.\n   */\n  blsVerify?: VerifyFunc;\n\n  /**\n   * The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @default 5\n   * This is used to verify the time the certificate was signed, particularly for validating Delegation certificates, which can live for longer than the default window of +/- 5 minutes. If the certificate is\n   * older than the specified age, it will fail verification.\n   */\n  maxAgeInMinutes?: number;\n}\n\nexport class Certificate {\n  private readonly cert: Cert;\n\n  /**\n   * Create a new instance of a certificate, automatically verifying it. Throws a\n   * CertificateVerificationError if the certificate cannot be verified.\n   * @constructs  Certificate\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {ArrayBuffer} options.certificate The bytes of the certificate\n   * @param {ArrayBuffer} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws {CertificateVerificationError}\n   */\n  public static async create(options: CreateCertificateOptions): Promise<Certificate> {\n    const cert = Certificate.createUnverified(options);\n\n    await cert.verify();\n    return cert;\n  }\n\n  private static createUnverified(options: CreateCertificateOptions): Certificate {\n    let blsVerify = options.blsVerify;\n    if (!blsVerify) {\n      blsVerify = bls.blsVerify;\n    }\n    return new Certificate(\n      options.certificate,\n      options.rootKey,\n      options.canisterId,\n      blsVerify,\n      options.maxAgeInMinutes,\n    );\n  }\n\n  private constructor(\n    certificate: ArrayBuffer,\n    private _rootKey: ArrayBuffer,\n    private _canisterId: Principal,\n    private _blsVerify: VerifyFunc,\n    // Default to 5 minutes\n    private _maxAgeInMinutes: number = 5,\n  ) {\n    this.cert = cbor.decode(new Uint8Array(certificate));\n  }\n\n  public lookup(path: Array<ArrayBuffer | string>): LookupResult {\n    // constrain the type of the result, so that empty HashTree is undefined\n    return lookup_path(path, this.cert.tree);\n  }\n\n  public lookup_label(label: ArrayBuffer): LookupResult {\n    return this.lookup([label]);\n  }\n\n  private async verify(): Promise<void> {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n\n    const lookupTime = lookupResultToBuffer(this.lookup(['time']));\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw new CertificateVerificationError('Certificate does not contain a time');\n    }\n\n    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n    const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n    const now = Date.now();\n    const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n    const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n\n    const certTime = decodeTime(lookupTime);\n\n    if (certTime.getTime() < earliestCertificateTime) {\n      throw new CertificateVerificationError(\n        `Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    } else if (certTime.getTime() > fiveMinutesFromNow) {\n      throw new CertificateVerificationError(\n        'Certificate is signed more than 5 minutes in the future. Certificate time: ' +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    }\n\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw new CertificateVerificationError('Signature verification failed');\n    }\n  }\n\n  private async _checkDelegationAndGetKey(d?: Delegation): Promise<ArrayBuffer> {\n    if (!d) {\n      return this._rootKey;\n    }\n\n    const cert: Certificate = await Certificate.createUnverified({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      // Do not check max age for delegation certificates\n      maxAgeInMinutes: Infinity,\n    });\n\n    if (cert.cert.delegation) {\n      throw new CertificateVerificationError('Delegation certificates cannot be nested');\n    }\n\n    await cert.verify();\n\n    const canisterInRange = check_canister_ranges({\n      canisterId: this._canisterId,\n      subnetId: Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n      tree: cert.cert.tree,\n    });\n    if (!canisterInRange) {\n      throw new CertificateVerificationError(\n        `Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(\n          d.subnet_id,\n        )}`,\n      );\n    }\n    const publicKeyLookup = lookupResultToBuffer(\n      cert.lookup(['subnet', d.subnet_id, 'public_key']),\n    );\n    if (!publicKeyLookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    return publicKeyLookup;\n  }\n}\n\nconst DER_PREFIX = fromHex(\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100',\n);\nconst KEY_LENGTH = 96;\n\nfunction extractDER(buf: ArrayBuffer): ArrayBuffer {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!bufEquals(prefix, DER_PREFIX)) {\n    throw new TypeError(\n      `BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`,\n    );\n  }\n\n  return buf.slice(DER_PREFIX.byteLength);\n}\n\n/**\n * utility function to constrain the type of a path\n * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup\n * @returns ArrayBuffer or Undefined\n */\nexport function lookupResultToBuffer(result: LookupResult): ArrayBuffer | undefined {\n  if (result.status !== LookupStatus.Found) {\n    return undefined;\n  }\n\n  if (result.value instanceof ArrayBuffer) {\n    return result.value;\n  }\n\n  if (result.value instanceof Uint8Array) {\n    return result.value.buffer;\n  }\n\n  return undefined;\n}\n\n/**\n * @param t\n */\nexport async function reconstruct(t: HashTree): Promise<ArrayBuffer> {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return hash(domain_sep('ic-hashtree-empty'));\n    case NodeType.Pruned:\n      return t[1] as ArrayBuffer;\n    case NodeType.Leaf:\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1] as ArrayBuffer));\n    case NodeType.Labeled:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-labeled'),\n          t[1] as ArrayBuffer,\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    case NodeType.Fork:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-fork'),\n          await reconstruct(t[1] as HashTree),\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction domain_sep(s: string): ArrayBuffer {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n\nexport enum LookupStatus {\n  Unknown = 'unknown',\n  Absent = 'absent',\n  Found = 'found',\n}\n\nexport interface LookupResultAbsent {\n  status: LookupStatus.Absent;\n}\n\nexport interface LookupResultUnknown {\n  status: LookupStatus.Unknown;\n}\n\nexport interface LookupResultFound {\n  status: LookupStatus.Found;\n  value: ArrayBuffer | HashTree;\n}\n\nexport type LookupResult = LookupResultAbsent | LookupResultUnknown | LookupResultFound;\n\nenum LabelLookupStatus {\n  Less = 'less',\n  Greater = 'greater',\n}\n\ninterface LookupResultGreater {\n  status: LabelLookupStatus.Greater;\n}\n\ninterface LookupResultLess {\n  status: LabelLookupStatus.Less;\n}\n\ntype LabelLookupResult = LookupResult | LookupResultGreater | LookupResultLess;\n\nexport function lookup_path(path: Array<ArrayBuffer | string>, tree: HashTree): LookupResult {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeType.Leaf: {\n        if (!tree[1]) {\n          throw new Error('Invalid tree structure for leaf');\n        }\n\n        if (tree[1] instanceof ArrayBuffer) {\n          return {\n            status: LookupStatus.Found,\n            value: tree[1],\n          };\n        }\n\n        if (tree[1] instanceof Uint8Array) {\n          return {\n            status: LookupStatus.Found,\n            value: tree[1].buffer,\n          };\n        }\n\n        return {\n          status: LookupStatus.Found,\n          value: tree[1],\n        };\n      }\n\n      default: {\n        return {\n          status: LookupStatus.Found,\n          value: tree,\n        };\n      }\n    }\n  }\n\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const lookupResult = find_label(label, tree);\n\n  switch (lookupResult.status) {\n    case LookupStatus.Found: {\n      return lookup_path(path.slice(1), lookupResult.value as HashTree);\n    }\n\n    case LabelLookupStatus.Greater:\n    case LabelLookupStatus.Less: {\n      return {\n        status: LookupStatus.Absent,\n      };\n    }\n\n    default: {\n      return lookupResult;\n    }\n  }\n}\n\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param t - the tree to flatten\n * @returns HashTree[] - the flattened tree\n */\nexport function flatten_forks(t: HashTree): HashTree[] {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return [];\n    case NodeType.Fork:\n      return flatten_forks(t[1] as HashTree).concat(flatten_forks(t[2] as HashTree));\n    default:\n      return [t];\n  }\n}\n\nexport function find_label(label: ArrayBuffer, tree: HashTree): LabelLookupResult {\n  switch (tree[0]) {\n    // if we have a labelled node, compare the node's label to the one we are\n    // looking for\n    case NodeType.Labeled:\n      // if the label we're searching for is greater than this node's label,\n      // we need to keep searching\n      if (isBufferGreaterThan(label, tree[1])) {\n        return {\n          status: LabelLookupStatus.Greater,\n        };\n      }\n\n      // if the label we're searching for is equal this node's label, we can\n      // stop searching and return the found node\n      if (bufEquals(label, tree[1])) {\n        return {\n          status: LookupStatus.Found,\n          value: tree[2],\n        };\n      }\n\n      // if the label we're searching for is not greater than or equal to this\n      // node's label, then it's less than this node's label, and we can stop\n      // searching because we've looked too far\n      return {\n        status: LabelLookupStatus.Less,\n      };\n\n    // if we have a fork node, we need to search both sides, starting with the left\n    case NodeType.Fork:\n      // search in the left node\n      const leftLookupResult = find_label(label, tree[1]);\n\n      switch (leftLookupResult.status) {\n        // if the label we're searching for is greater than the left node lookup,\n        // we need to search the right node\n        case LabelLookupStatus.Greater: {\n          const rightLookupResult = find_label(label, tree[2]);\n\n          // if the label we're searching for is less than the right node lookup,\n          // then we can stop searching and say that the label is provably Absent\n          if (rightLookupResult.status === LabelLookupStatus.Less) {\n            return {\n              status: LookupStatus.Absent,\n            };\n          }\n\n          // if the label we're searching for is less than or equal to the right\n          // node lookup, then we let the caller handle it\n          return rightLookupResult;\n        }\n\n        // if the left node returns an uncertain result, we need to search the\n        // right node\n        case LookupStatus.Unknown: {\n          let rightLookupResult = find_label(label, tree[2]);\n\n          // if the label we're searching for is less than the right node lookup,\n          // then we also need to return an uncertain result\n          if (rightLookupResult.status === LabelLookupStatus.Less) {\n            return {\n              status: LookupStatus.Unknown,\n            };\n          }\n\n          // if the label we're searching for is less than or equal to the right\n          // node lookup, then we let the caller handle it\n          return rightLookupResult;\n        }\n\n        // if the label we're searching for is not greater than the left node\n        // lookup, or the result is not uncertain, we stop searching and return\n        // whatever the result of the left node lookup was, which can be either\n        // Found or Absent\n        default: {\n          return leftLookupResult;\n        }\n      }\n\n    // if we encounter a Pruned node, we can't know for certain if the label\n    // we're searching for is present or not\n    case NodeType.Pruned:\n      return {\n        status: LookupStatus.Unknown,\n      };\n\n    // if the current node is Empty, or a Leaf, we can stop searching because\n    // we know for sure that the label we're searching for is not present\n    default:\n      return {\n        status: LookupStatus.Absent,\n      };\n  }\n}\n\n/**\n * Check if a canister falls within a range of canisters\n * @param canisterId Principal\n * @param ranges [Principal, Principal][]\n * @returns\n */\nexport function check_canister_ranges(params: {\n  canisterId: Principal;\n  subnetId: Principal;\n  tree: HashTree;\n}): boolean {\n  const { canisterId, subnetId, tree } = params;\n  const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n\n  if (rangeLookup.status !== LookupStatus.Found || !(rangeLookup.value instanceof ArrayBuffer)) {\n    throw new Error(`Could not find canister ranges for subnet ${subnetId}`);\n  }\n\n  const ranges_arr: Array<[Uint8Array, Uint8Array]> = cbor.decode(rangeLookup.value);\n  const ranges: Array<[Principal, Principal]> = ranges_arr.map(v => [\n    Principal.fromUint8Array(v[0]),\n    Principal.fromUint8Array(v[1]),\n  ]);\n\n  const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n\n  return canisterInRange;\n}\n"]}